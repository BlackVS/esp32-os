#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"
#include "esp_log.h"

#include "esp32_tools.h"
#include "esp32_tft_spi.h"
#include "esp32_tft_constants.h"

///////////////////////////////////////////////////////////////////////////////

#define CMDDELAY 0xFF

#undef TAG
#define TAG "SPITFT"


static const uint8_t ST7735_128x128x16_INIT[] =
{
    0x01, CMDDELAY,  150,   // SWRESET sw reset. not needed, we do hardware reset
    0x11, CMDDELAY,  255,   // SLPOUT exit sleep mode
    0xB1, 0x03, 0x01, 0x2C, 0x2D,  // FRMCTR1 frame rate control 1, use by default
    0xB2, 0x03, 0x01, 0x2C, 0x2D,  // FRMCTR2, Frame Rate Control (In Idle mode/ 8-colors)
    0xB3, 0x06,              // FRMCTR3 (B3h): Frame Rate Control (In Partial mode/ full colors)
                0x01, 0x2C, 0x2D,
                0x01, 0x2C, 0x2D,
    0xB4, 0x01, 0x07,        // INVCTR display inversion, use by default
    0xB6, 0x02, 0x15, 0x02,  // DISSET5
    0xC0, 0x03, 0xA2, 0x02, 0x84,  // PWCTR1 power control 1
    0xC1, 0x01, 0xC5,        // PWCTR2 power control 2
    0xC2, 0x02, 0x0A, 0x00,  // PWCTR3 power control 3
    0xC3, 0x02, 0x8A, 0x2A,  // PWCTR4 (C3h): Power Control 4 (in Idle mode/ 8-colors)
    0xC4, 0x02, 0x8A, 0xEE,  // PWCTR5 (C4h): Power Control 5 (in Partial mode/ full-colors)
    0xC5, 0x01, 0x0E,        // VMCTR vcom control 1
    0x20, 0x00,              // INVOFF (20h): Display Inversion Off
//    0xFC, 0x02, 0x11, 0x15,  // PWCTR6
    0x36, 0x01, 0b00000000,  // MADCTL
    0x3A, 0x01, 0x05,        // COLMOD set 16-bit pixel format
//    0x26, 1, 0x08,        // GAMSET set gamma curve: valid values 1, 2, 4, 8
//    0xF2, 1, 0x01,        // enable gamma adjustment, 0 - to disable
    0xE0, 0x10, // GMCTRP1 positive gamma correction
                0x0F, 0x1A, 0x0F, 0x18,
                0x2F, 0x28, 0x20, 0x22,
                0x1F, 0x1B, 0x23, 0x37,
                0x00, 0x07, 0x02, 0x10,
    0xE1, 0x10, // GMCTRN1 negative gamma correction
                0x0F, 0x1B, 0x0F, 0x17,
                0x33, 0x2C, 0x29, 0x2E,
                0x30, 0x30, 0x39, 0x3F,
                0x00, 0x07, 0x03, 0x10,
//    0xC7,  1,  0x40,                // vcom offset
//    0x2A,  CMD_ARG,  0x00, CMD_ARG, 0x00, CMD_ARG, 0x00, CMD_ARG, 0x7F,   // set column address, not needed. set by direct API
//    0x2B,  CMD_ARG,  0x00, CMD_ARG, 0x00, CMD_ARG, 0x00, CMD_ARG, 0x9F,   // set page address, not needed. set by direct API
    0x29, CMDDELAY,  100, // DISPON display on
    0x13, CMDDELAY,   10, // NORON
};

static const uint8_t ST7735_128x160x16_INIT[] =
{
    0x01, CMDDELAY,  150,   // SWRESET sw reset. not needed, we do hardware reset
    0x11, CMDDELAY,  255,   // SLPOUT exit sleep mode
    0xB1, 0x03, 0x01, 0x2C, 0x2D,  // FRMCTR1 frame rate control 1, use by default
    0xB2, 0x03, 0x01, 0x2C, 0x2D,  // FRMCTR2, Frame Rate Control (In Idle mode/ 8-colors)
    0xB3, 0x06,              // FRMCTR3 (B3h): Frame Rate Control (In Partial mode/ full colors)
                0x01, 0x2C, 0x2D,
                0x01, 0x2C, 0x2D,
    0xB4, 0x01, 0x07,        // INVCTR display inversion, use by default
    0xB6, 0x02, 0x15, 0x02,  // DISSET5
    0xC0, 0x03, 0xA2, 0x02, 0x84,  // PWCTR1 power control 1
    0xC1, 0x01, 0xC5,        // PWCTR2 power control 2
    0xC2, 0x02, 0x0A, 0x00,  // PWCTR3 power control 3
    0xC3, 0x02, 0x8A, 0x2A,  // PWCTR4 (C3h): Power Control 4 (in Idle mode/ 8-colors)
    0xC4, 0x02, 0x8A, 0xEE,  // PWCTR5 (C4h): Power Control 5 (in Partial mode/ full-colors)
    0xC5, 0x01, 0x0E,        // VMCTR vcom control 1
    0x20, 0x00,              // INVOFF (20h): Display Inversion Off
//    0xFC, 0x02, 0x11, 0x15,  // PWCTR6
    0x36, 0x01, 0b00000000,  // MADCTL
    0x3A, 0x01, 0x05,        // COLMOD set 16-bit pixel format
//    0x26, 1, 0x08,        // GAMSET set gamma curve: valid values 1, 2, 4, 8
//    0xF2, 1, 0x01,        // enable gamma adjustment, 0 - to disable
    0xE0, 0x10, // GMCTRP1 positive gamma correction
                0x0F, 0x1A, 0x0F, 0x18,
                0x2F, 0x28, 0x20, 0x22,
                0x1F, 0x1B, 0x23, 0x37,
                0x00, 0x07, 0x02, 0x10,
    0xE1, 0x10, // GMCTRN1 negative gamma correction
                0x0F, 0x1B, 0x0F, 0x17,
                0x33, 0x2C, 0x29, 0x2E,
                0x30, 0x30, 0x39, 0x3F,
                0x00, 0x07, 0x03, 0x10,
//    0xC7,  1,  0x40,                // vcom offset
//    0x2A,  CMD_ARG,  0x00, CMD_ARG, 0x00, CMD_ARG, 0x00, CMD_ARG, 0x7F,   // set column address, not needed. set by direct API
//    0x2B,  CMD_ARG,  0x00, CMD_ARG, 0x00, CMD_ARG, 0x00, CMD_ARG, 0x9F,   // set page address, not needed. set by direct API
    0x29, CMDDELAY,  100, // DISPON display on
    0x13, CMDDELAY,   10, // NORON
};

static const uint8_t ST7735_80x160x16_INIT[] =
{
    0x01, CMDDELAY,  150,         // SWRESET sw reset. not needed, we do hardware reset
    0x11, CMDDELAY,  255,         // SLPOUT exit sleep mode
    0xB1, 0x03, 0x01, 0x2C, 0x2D,  // Rate = fosc/(1x2+40) * (LINE+2C+2D)
    0xB2, 0x03, 0x01, 0x2C, 0x2D,  // FRMCTR2, Rate = fosc/(1x2+40) * (LINE+2C+2D)
    0xB3, 0x06,                    // FRMCTR3 (B3h): Frame Rate Control (In Partial mode/ full colors)
      0x01, 0x2C, 0x2D,       //     Dot inversion mode
      0x01, 0x2C, 0x2D,       //     Line inversion mode
    ST7735_INVCTR , 1      ,  //  6: Display inversion ctrl, 1 arg, no delay:
      0x07,                   //     No inversion
    ST7735_PWCTR1 , 3      ,  //  7: Power control, 3 args, no delay:
      0xA2,
      0x02,                   //     -4.6V
      0x84,                   //     AUTO mode
    ST7735_PWCTR2 , 1      ,  //  8: Power control, 1 arg, no delay:
      0xC5,                   //     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD
    ST7735_PWCTR3 , 2      ,  //  9: Power control, 2 args, no delay:
      0x0A,                   //     Opamp current small
      0x00,                   //     Boost frequency
    ST7735_PWCTR4 , 2      ,  // 10: Power control, 2 args, no delay:
      0x8A,                   //     BCLK/2, Opamp current small & Medium low
      0x2A,  
    ST7735_PWCTR5 , 2      ,  // 11: Power control, 2 args, no delay:
      0x8A, 0xEE,
    ST7735_VMCTR1 , 1      ,  // 12: Power control, 1 arg, no delay:
      0x0E,
    ST7735_INVOFF , 0      ,  // 13: Don't invert display, no args, no delay
    ST7735_MADCTL , 1      ,  // 14: Memory access control (directions), 1 arg:
      0xC8,                   //     row addr/col addr, bottom to top refresh
    ST7735_COLMOD , 1      ,  // 15: set color mode, 1 arg, no delay:
      0x05,                   //     16-bit color
    ST7735_CASET  , 4      ,  //  1: Column addr set, 4 args, no delay:
      0x00, 0x02,             //     XSTART = 0
      0x00, 0x7F+0x02,        //     XEND = 127
    ST7735_RASET  , 4      ,  //  2: Row addr set, 4 args, no delay:
      0x00, 0x01,             //     XSTART = 0
      0x00, 0x9F+0x01,        //     XEND = 159
//++
    ST7735_INVON , 0      ,  // 13: Don't invert display, no args, no delay
    ST7735_GMCTRP1, 16      , //  1: 16 args, no delay:
      0x02, 0x1c, 0x07, 0x12,
      0x37, 0x32, 0x29, 0x2d,
      0x29, 0x25, 0x2B, 0x39,
      0x00, 0x01, 0x03, 0x10,
    ST7735_GMCTRN1, 16      , //  2: 16 args, no delay:
      0x03, 0x1d, 0x07, 0x06,
      0x2E, 0x2C, 0x29, 0x2D,
      0x2E, 0x2E, 0x37, 0x3F,
      0x00, 0x00, 0x02, 0x10,
    0x13, CMDDELAY,   10, // NORON
    0x29, CMDDELAY,  100, // DISPON display on
};



// static const PROGMEM uint8_t SH1106_128x64x1_VCCINT_SPI_INIT[] =
// {
//     SSD1306_DISPLAY_OFF,        0x00,       // display off
//     SSD1306_SETDISPLAYCLOCKDIV, 0x01, 0x80, // set to default ratio/osc frequency
//     SSD1306_SETMULTIPLEX,       0x01, 0x3f,  // Reset to default MUX. See datasheet
//     SSD1306_SETDISPLAYOFFSET,   0x01, 0x00, // no offset
//     SSD1306_SETSTARTLINE| 0x00, 0x00,       // First line to start scanning from
//     SSD1306_CHARGEPUMP,         0x01, 0x14, // Enable charge pump
//     SSD1306_SEGREMAP    | 0x01, 0x00,       // Use reverse mapping. 0x00 - is normal mapping
//     SSD1306_COMSCANDEC,         0x00,       // Scan from 127 to 0 (Reverse scan)
//     SSD1306_SETCOMPINS,         0x01, 0x12, // set divide ratio
//     SSD1306_SETCONTRAST,        0x01, 0x7F, // contast value to 0x7F according to datasheet cf 7f?
//     SSD1306_SETPRECHARGE,       0x01, 0x22, // switch precharge to 0x22 0xF1 0x1f ?
//     SSD1306_SETVCOMDETECT,      0x01, 0x20, // vcom deselect to 0x20 // 0x40

//     //SSD1306_MEMORY_ADDR_MODE,   0x01, 0x00, // Page horizontal Addressing mode
//     SSD1306_NORMAL_DISPLAY,     0x00,       // Normal display
//     SSD1306_DISPLAYALLON_RESUME,0x00,       // Display resume
//     SSD1306_DISPLAY_ON,         0x00,       // Display on
// };


// static const PROGMEM uint8_t SH1106_128x64x1_VCCINT_SPI_INIT[] =
// {
//     SSD1306_DISPLAY_OFF,        0x00,       // display off
//     SSD1306_SETDISPLAYCLOCKDIV, 0x01, 0x80, // set to default ratio/osc frequency
//     SSD1306_SETMULTIPLEX,       0x01, 0x3f,  // Reset to default MUX. See datasheet
//     SSD1306_SETDISPLAYOFFSET,   0x01, 0x00, // no offset
//     SSD1306_SETSTARTLINE| 0x00, 0x00,       // First line to start scanning from
//     SSD1306_CHARGEPUMP,         0x01, 0x14, // Enable charge pump
//     SSD1306_MEMORY_ADDR_MODE,   0x00,
//     SSD1306_SEGREMAP    | 0x01, 0x00,       // Use reverse mapping. 0x00 - is normal mapping
//     SSD1306_COMSCANDEC,         0x00,       // Scan from 127 to 0 (Reverse scan)
//     SSD1306_SETCOMPINS,         0x01, 0x12, // set divide ratio
//     SSD1306_SETCONTRAST,        0x01, 0xCF, // contast value to 0x7F according to datasheet cf 7f?
//     SSD1306_SETPRECHARGE,       0x01, 0xF1, // switch precharge to 0x22 0xF1 0x1f ?
//     SSD1306_SETVCOMDETECT,      0x01, 0x40, // vcom deselect to 0x20 // 0x40
//     SSD1306_DISPLAYALLON_RESUME,0x00,       // Display resume
//     SSD1306_NORMAL_DISPLAY,     0x00,       // Normal display
//     SSD1306_DISPLAY_ON,         0x00,       // Display on
// };



static const PROGMEM uint8_t SH1106_128x64x1_VCCINT_SPI_INIT[] =
{
    SSD1306_DISPLAY_OFF,        0x00,       // display off
    SSD1306_SETDISPLAYCLOCKDIV, 0x01, 0x80, // set to default ratio/osc frequency
    SSD1306_SETMULTIPLEX,       0x01, 0x3f,  // Reset to default MUX. See datasheet
    SSD1306_SETDISPLAYOFFSET,   0x01, 0x00, // no offset
    SSD1306_SETSTARTLINE| 0x00, 0x00,       // First line to start scanning from
    SSD1306_CHARGEPUMP,         0x01, 0x14, // Enable charge pump
    SSD1306_MEMORY_ADDR_MODE,   0x00,
    SSD1306_SEGREMAP    | 0x01, 0x00,       // Use reverse mapping. 0x00 - is normal mapping
    SSD1306_COMSCANDEC,         0x00,       // Scan from 127 to 0 (Reverse scan)
    SSD1306_SETCOMPINS,         0x01, 0x12, // set divide ratio
    SSD1306_SETCONTRAST,        0x01, 0x7F, // contast value to 0x7F according to datasheet cf 7f? cf?
    SSD1306_SETPRECHARGE,       0x01, 0xF1, // switch precharge to 0x22 0xF1 0x1f ?
    SSD1306_SETVCOMDETECT,      0x01, 0x40, // vcom deselect to 0x20 // 0x40
    SSD1306_DISPLAYALLON_RESUME,0x00,       // Display resume
    SSD1306_NORMAL_DISPLAY,     0x00,       // Normal display
    SSD1306_DISPLAY_ON,         0x00,       // Display on
    //SH1106_DEACTIVATE_SCROLL,   0x00
};


/////////////////////////////////////////////////////////////////////////////////

#undef TAG
#define TAG "SPITFT"

ESP32_SPI_TFT::ESP32_SPI_TFT(ESP32_SPIdevice& dev, unsigned int width, unsigned int height, unsigned int ofs_x, unsigned int ofs_y, 
      TFT_ROTATION display_rotation, 
      TFT_TYPE display_type)
 : m_device(dev),
   m_width(width),
   m_height(height),
   m_offset_x(ofs_x),
   m_offset_y(ofs_y),
   m_display_rotation(display_rotation),
   m_display_type(display_type)
{

}

esp_err_t ESP32_SPI_TFT::begin()
{
    //ESP_LOGD(TAG, "%s()", __FUNCTION__);
	  m_device.begin();
    init();//send initial data to TFT
    return ESP_OK;
}

#define CMD_DELAY 0xff
void ESP32_SPI_TFT::configureDisplay(const uint8_t *config, uint8_t configSize)
{
    int i=0;
    while(i<configSize)
    {
        uint8_t cmd = config[i++];
        int arg_len = config[i++];
        //single cmd + delay
        if( arg_len==CMDDELAY) {
            m_device.write_cmd(cmd);
            delay(config[i++]);
            continue;
        }
        //complex command
        m_device.write_cmd(cmd);
        if(arg_len) {
            m_device.set_data_mode();
            m_device.write_bytes(&config[i], arg_len);
            i+=arg_len;
        }

    }
}

esp_err_t ESP32_SPI_TFT::init()
{
    //ESP_LOGD(TAG, "%s()", __FUNCTION__);
    // Give LCD some time to initialize. Refer to ST7735 datasheet
    delay(120);
    
    TFT_TYPE dtype=m_display_type;
    if(dtype==TFT_AUTO) 
    {
        if(m_width==128 && m_height==128)
            dtype=TFT_ST7735_128x128x16;
        else 
        if(m_width==128 && m_height==160)
            dtype=TFT_ST7735_128x160x16;
        else
        if(m_width==80 && m_height==160)
            dtype=TFT_ST7735_M5STICKC;
        else
            dtype=TFT_ST7735_128x128x16;

    }
    ESP_LOGD(TAG, "DTYPE=%d", (int)dtype);
    switch(dtype)
    {
        case TFT_ST7735_128x128x16:
            //SPI_LOGD(TAGSPI,"ST7735_128x128x16");
            configureDisplay(ST7735_128x128x16_INIT, sizeof(ST7735_128x128x16_INIT));
            break;
        case TFT_ST7735_128x160x16:
            //SPI_LOGD(TAGSPI,"ST7735_128x160x16");
            configureDisplay(ST7735_128x160x16_INIT, sizeof(ST7735_128x160x16_INIT));
            break;
        case TFT_ST7735_M5STICKC:
            {
                //SPI_LOGD(TAGSPI,"ST7735_M5STICKC");
                configureDisplay(ST7735_80x160x16_INIT, sizeof(ST7735_80x160x16_INIT));
            }
            break;
        case TFT_SH1106_128x64x1:
            configureDisplay(SH1106_128x64x1_VCCINT_SPI_INIT, sizeof(SH1106_128x64x1_VCCINT_SPI_INIT));
            break;
        default:
            ESP_LOGE(TAG, "Unsupported display type, type=%d", (int)m_display_type);
            break;
    }
    _set_rotation();
    return ESP_OK;
}


void ESP32_SPI_TFT::send(uint8_t data)
{
    m_device.write_byte(data, true);
}


void ESP32_SPI_TFT::startBlock(unsigned int x1, unsigned int y, unsigned int w)
{
    //SPI_LOGD(TAGSPI,"%s", __FUNCTION__);


    m_block_y = y;
    m_block_x = x1;

    unsigned int x2 = w ? (x1 + w - 1) : ( m_width - 1);
    x2 = (x2 < m_width) ? x2 : (m_width-1);

    switch(m_display_type)
    {
        case TFT_ST7735_128x128x16:
        case TFT_ST7735_128x160x16:
        case TFT_ST7735_M5STICKC:
            //X
            m_device.write_cmd(0x2A);
            m_device.set_data_mode(); // According to datasheet all args must be passed in data mode
            m_device.write_2x16bits( x1 + m_offset_x, x2 + m_offset_x );
            //m_device.write_16bits( x1 + m_offset_x );
            //m_device.write_16bits( x2 + m_offset_x );
            //Y
            m_device.write_cmd(0x2B);
            m_device.set_data_mode(); // According to datasheet all args must be passed in data mode
            //m_device.write_16bits( y + m_offset_y );
            //m_device.write_16bits( m_height - 1 + m_offset_y );
            m_device.write_2x16bits( y + m_offset_y, m_height - 1 + m_offset_y );
            //Write
            m_device.write_cmd(0x2C);
            m_device.set_data_mode(); // According to datasheet all args must be passed in data mode
            // if m_dc=-1 ->  this->send(0x40);
            break;

        case TFT_SH1106_128x64x1:
            m_device.write_cmd(SH1106_SETPAGEADDRESS | y); 
            m_device.write_cmd(SSD1306_SETHIGHCOLUMN | ((x1+2)>>4)); 
            m_device.write_cmd(SSD1306_SETLOWCOLUMN | ((x1+2) & 0x0f)); 
            m_device.set_data_mode();
            break;

        default:
            ESP_LOGE(TAG, "Unsupported display type, type=%d", (int)m_display_type);
            break;
    }

}

void ESP32_SPI_TFT::nextBlock()
{
    switch(m_display_type)
    {
        case TFT_ST7735_128x128x16:
        case TFT_ST7735_128x160x16:
        case TFT_ST7735_M5STICKC:
            break;
        case TFT_SH1106_128x64x1:
            m_device.flush_data();
            startBlock(m_block_x, m_block_y+1, 0);
            break;
        default:
            ESP_LOGE(TAG, "Unsupported display type, type=%d", (int)m_display_type);
    }  
}


void ESP32_SPI_TFT::endBlock()
{
    //in the case of buffered write - flush buffer
    m_device.flush_data();
}


const uint8_t _ST7735_M5STICKC[TFT_ROTATION_MAX] = {
  TFT_MAD_MX | TFT_MAD_MY | TFT_MAD_MH | TFT_MAD_BGR,
  TFT_MAD_MV | TFT_MAD_MY | TFT_MAD_BGR,
  TFT_MAD_BGR,
  TFT_MAD_MX | TFT_MAD_MV | TFT_MAD_BGR,
};

// ram_mode = 0b00000000;
// ram_mode = 0b01100000;
// ram_mode = 0b11000000;
// ram_mode = 0b10100000;

void ESP32_SPI_TFT::_set_rotation()
{
    //if ((rotation^m_display_rotation) & 0x01) - in the case of outer call
    if (m_display_rotation & 0x01) //first time
    {
        unsigned int t;
        //SWAP(m_offset_x, m_offset_y);
        t=m_offset_x; m_offset_x=m_offset_y; m_offset_y=t;
        //SWAP(m_width, m_height);
        t=m_width; m_width=m_height; m_height=t;
    }

    m_device.write_cmd(ST7735_DISPOFF);
    m_device.write_byte(TFT_MADCTL);
    m_device.set_data_mode();

    uint8_t code=TFT_MAD_BGR;
    switch(m_display_type)
    {
      case TFT_ST7735_M5STICKC:
        code=_ST7735_M5STICKC[m_display_rotation];
      default:
        break;
    }
    m_device.write_byte(code);
    m_device.write_cmd(ST7735_DISPON);

    if(m_base)
    m_base->on_rotation_changed();
}


void ESP32_SPI_TFT::set_notify_base(ESP32_TFT_Notifications* base)
{
    m_base=base;
    //printf("PTR: %p (set_notify_base)\n", base);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


const uint8_t Waveshare12864[1024] PROGMEM =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x11,0x11,0x00,0x9C,0x64,0x42,0x1C,0x78,0x7A,0x78,0xEF,0xB8,0x30,0x89,0x8C,0x70,
    0x19,0x91,0x88,0x9C,0xF4,0x63,0x1E,0x78,0x7A,0x79,0xEF,0x3C,0x78,0x89,0x9E,0xF0,
    0x09,0x91,0x88,0xB1,0x84,0x63,0x12,0x40,0x42,0x43,0x02,0x24,0xCC,0xC9,0x30,0x80,
    0x09,0x91,0x88,0xB1,0x84,0x67,0x12,0x40,0x42,0x42,0x02,0x24,0x84,0xC9,0x20,0x80,
    0x09,0x92,0x89,0xB0,0x84,0x65,0x12,0x40,0x42,0x42,0x02,0x24,0x84,0xC9,0x20,0xC0,
    0x0A,0xB2,0x4D,0x1C,0xC7,0xE5,0x96,0x78,0x7A,0x72,0x02,0x2C,0x84,0xA9,0x20,0x60,
    0x0A,0xA2,0x45,0x14,0x67,0xE4,0x9C,0x70,0x72,0x52,0x02,0x38,0x84,0xA9,0x20,0x30,
    0x0A,0x63,0xC5,0x30,0x34,0x67,0x94,0x40,0x42,0x42,0x02,0x28,0x84,0xB9,0x20,0x10,
    0x06,0x67,0xC7,0x30,0x14,0x6F,0x92,0x40,0x42,0x42,0x02,0x24,0x84,0x99,0x20,0x10,
    0x06,0x64,0x66,0x30,0x14,0x68,0x92,0x40,0x42,0x43,0x02,0x24,0x8C,0x99,0x20,0x10,
    0x06,0x64,0x22,0x3D,0xB4,0x68,0xD3,0x78,0x7A,0x79,0xE2,0x26,0x78,0x89,0xBE,0xF0,
    0x04,0x44,0x22,0x1C,0xE4,0x48,0x51,0x78,0x7A,0x79,0xE2,0x22,0x70,0x89,0x9E,0xE0,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x3F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x3F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x3F,0xFF,0xFF,0x80,0x00,0x08,0x30,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x3F,0xFF,0xF7,0xC0,0x06,0xDB,0x30,0x3F,0xFF,0xFC,0x00,0x70,0x00,0x7F,0xFF,0xF0,
    0x3F,0xFF,0xE7,0xE0,0x0E,0xDB,0x30,0x3F,0xFF,0xFC,0x7F,0xFF,0xF8,0x7F,0xFF,0xF0,
    0x3F,0xFF,0xC7,0xF0,0x0C,0xDB,0x7E,0x00,0x18,0x00,0x7F,0xFF,0xF8,0x7F,0xFF,0xF0,
    0x3F,0xFF,0x87,0xF0,0x1C,0xDB,0xFE,0x00,0x18,0x00,0x7F,0xFF,0xF8,0x00,0x00,0xF0,
    0x3F,0xFF,0x07,0xF8,0x1C,0xDB,0xF0,0x3F,0xFF,0xFC,0x60,0x70,0x38,0x00,0x01,0xE0,
    0x3F,0xFF,0x87,0xFC,0x18,0xDB,0xC0,0x3F,0xFF,0xF8,0x60,0x70,0x38,0x00,0x01,0xC0,
    0x20,0xC3,0x86,0x3C,0x06,0xFF,0x00,0x30,0x18,0x18,0x60,0x70,0x38,0x00,0x03,0xC0,
    0x30,0xC3,0x0C,0x3C,0x06,0xFF,0x0C,0x30,0x18,0x18,0x60,0x70,0x38,0x00,0x03,0x80,
    0x30,0x43,0x0C,0x1E,0x0E,0xFF,0x6C,0x33,0x18,0xD8,0x60,0x70,0x38,0x07,0xFF,0x00,
    0x30,0x00,0x1C,0x1E,0x0E,0x00,0x6C,0x33,0x9B,0xD8,0x70,0x70,0x38,0x07,0xFF,0x00,
    0x38,0x00,0x08,0x0E,0x1C,0xFE,0x7C,0x30,0x18,0x18,0x7F,0xFF,0xF8,0x07,0xFE,0x00,
    0x38,0x00,0x08,0x0E,0x1C,0xFE,0x3C,0x30,0x19,0x18,0x7F,0xFF,0xF8,0x07,0xFE,0x00,
    0x38,0x00,0x00,0x06,0x1C,0xFE,0x38,0x31,0x9B,0x98,0x60,0x70,0x38,0x00,0x0E,0x00,
    0x3C,0x10,0x00,0x86,0x0C,0x00,0x38,0x33,0x99,0xD8,0x60,0x70,0x38,0x00,0x0E,0x00,
    0x3C,0x10,0x00,0x82,0x0C,0x00,0x38,0x00,0x00,0x00,0x60,0x70,0x38,0x00,0x0E,0x00,
    0x3C,0x18,0x41,0x86,0x0C,0x7E,0x38,0x00,0x00,0x00,0x60,0x70,0x38,0xFF,0xFF,0xF0,
    0x1E,0x38,0x41,0x86,0x0C,0x7E,0x18,0x3F,0xFF,0xF8,0x60,0x70,0x38,0xFF,0xFF,0xF0,
    0x1E,0x38,0xE3,0x8E,0x0C,0x7E,0x18,0x3F,0xFF,0xF8,0x60,0x70,0x38,0xFF,0xFF,0xF0,
    0x1E,0x7C,0xE2,0x0E,0x0C,0x66,0x38,0x00,0x00,0x18,0x7F,0xFF,0xF8,0x00,0x0E,0x00,
    0x1F,0xFF,0xFE,0x1E,0x0C,0x66,0x38,0x00,0x00,0x18,0x7F,0xFF,0xF0,0x00,0x0E,0x00,
    0x0F,0xFF,0xFE,0x0E,0x0C,0x66,0x38,0x1F,0xFF,0xF8,0x7F,0xFF,0xF0,0x00,0x0E,0x00,
    0x0F,0xFF,0xFE,0x1E,0x0C,0x66,0x3C,0x1F,0xFF,0xF8,0x00,0x70,0x00,0x00,0x0E,0x00,
    0x07,0xFF,0xFE,0x3E,0x0C,0x66,0x3C,0x10,0x00,0x38,0x00,0x70,0x00,0x00,0x0E,0x00,
    0x03,0xFF,0xFE,0x7E,0x0C,0x66,0x7C,0x00,0x00,0x18,0x00,0x70,0x00,0x00,0x1E,0x00,
    0x01,0xFF,0xFE,0xFE,0x0C,0xE7,0xEE,0x00,0x00,0x18,0x00,0x7F,0xF8,0x3F,0xFE,0x00,
    0x00,0xFF,0xFF,0xFE,0x0C,0xE7,0xEE,0x3F,0xFF,0xF8,0x00,0x3F,0xF8,0x3F,0xFE,0x00,
    0x00,0x7F,0xFF,0xFE,0x0C,0xC7,0xC6,0x3F,0xFF,0xF8,0x00,0x3F,0xF8,0x3F,0xFC,0x00,
    0x00,0x1F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x03,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


void ESP32_SPI_TFT::SH1106_pixel(int x, int y, char color, uint8_t* buffer)
{
    if(x > m_width || y > m_height)return ;
    if(color)
        buffer[x+(y/8)*m_width] |= 1<<(y%8);
    else
        buffer[x+(y/8)*m_width] &= ~(1<<(y%8));
}


void ESP32_SPI_TFT::SH1106_bitmap(uint8_t x, uint8_t y, const uint8_t *pBmp, uint8_t chWidth, uint8_t chHeight, uint8_t* buffer)
{
    uint8_t i,j,byteWidth = (chWidth + 7)/8;
    for(j = 0;j < chHeight;j++){
        for(i = 0;i <chWidth;i ++){
            // if( pgm_read_byte(pBmp +j*byteWidth+i/8) & (128 >> (i & 7))){
            //     SH1106_pixel(x+i,y+j,1,buffer);
            // }
            if( pBmp[j*byteWidth+i/8] & (128 >> (i & 7))){
                 SH1106_pixel(x+i,y+j, 1, buffer);
             }
        }
    }        
}

void ESP32_SPI_TFT::SH1106_display(uint8_t* buffer)
{
    uint8_t page;
    uint8_t *pBuf = buffer;
    
    for (page = 0; page < 8; page++) {  
        /* set page address */
        m_device.write_cmd(0xB0 + page);
        /* set low column address */
        m_device.write_cmd(0x02); 
        /* set high column address */
        m_device.write_cmd(0x10); 
        /* write data */
        m_device.set_data_mode(); //digitalWrite(OLED_DC, HIGH);
        m_device.write_bytes(pBuf, m_width); // SPIWrite(pBuf, WIDTH); 
        pBuf += m_width;
    }
}

void ESP32_SPI_TFT::SH1106_clear(uint8_t* buffer)
{
    int i;
    for(i = 0;i < m_width * m_height / 8;i++)
    {
        buffer[i] = 0;
    }
}

void ESP32_SPI_TFT::test()
{
  uint8_t* oled_buf=(uint8_t*) malloc( m_width * m_height / 8 );

  SH1106_clear(oled_buf);
  SH1106_bitmap(0, 0, Waveshare12864, 128, 64, oled_buf);
  SH1106_display(oled_buf);

  free(oled_buf);
}

